/************************************************************************
 * MechSys - Open Library for Mechanical Systems                        *
 * Copyright (C) 2005 Dorival M. Pedroso, Ra√∫l D. D. Farfan             *
 *                                                                      *
 * This program is free software: you can redistribute it and/or modify *
 * it under the terms of the GNU General Public License as published by *
 * the Free Software Foundation, either version 3 of the License, or    *
 * any later version.                                                   *
 *                                                                      *
 * This program is distributed in the hope that it will be useful,      *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of       *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the         *
 * GNU General Public License for more details.                         *
 *                                                                      *
 * You should have received a copy of the GNU General Public License    *
 * along with this program. If not, see <http://www.gnu.org/licenses/>  *
 ************************************************************************/

// STL
#include <iostream>
#include <cmath>

// MechSys
#include <mechsys/linalg/matvec.h>
#include <mechsys/util/fatal.h>
#include <mechsys/util/util.h>

using std::cout;
using std::endl;

double CheckSvd (char const * Key, Mat_t const & M, Mat_t const & CorrectU, Vec_t const & CorrectS, Mat_t const & CorrectVt, double Tol)
{
	Mat_t U, Vt, D(M.num_rows(),M.num_cols());
    Vec_t S;
	Svd (M, U, S, Vt);
    set_to_zero(D);
    for (size_t i=0; i<S.size(); ++i) D(i,i) = S(i);
    Mat_t UDVt (U*D*Vt); // == M
    double err_U    = CompareMatrices (U, CorrectU);
    double err_Vt   = CompareMatrices (Vt,CorrectVt);
    double err_S    = CompareVectors  (S, CorrectS);
    double err_UDVt = CompareMatrices (UDVt, M);
	cout << Key << ": error(U)      = " << (err_U    >Tol ? "[1;31m" : "[1;32m") << err_U     << "[0m\n";
	cout << Key << ": error(Vt)     = " << (err_Vt   >Tol ? "[1;31m" : "[1;32m") << err_Vt    << "[0m\n";
	cout << Key << ": error(S)      = " << (err_S    >Tol ? "[1;31m" : "[1;32m") << err_S     << "[0m\n";
	cout << Key << ": error(UDVt)   = " << (err_UDVt >Tol ? "[1;31m" : "[1;32m") << err_UDVt  << "[0m\n";
	return err_U + err_Vt + err_S + err_UDVt;
}

double CheckInv (char const * Key, Mat_t const & M, Mat_t const & CorrectInvM, double Tol)
{
	Mat_t Mi;
	Inv (M, Mi);
	Mat_t MMi  (M*Mi);
    Mat_t MMiM (M*Mi*M); // == M
	double err_Mi   = CompareMatrices (Mi,CorrectInvM);
	double err_MMi  = CheckDiagonal   (MMi);
    double err_MMiM = CompareMatrices (MMiM, M);
	cout << Key << ": error(Inv)    = " << (err_Mi  >Tol ? "[1;31m" : "[1;32m") << err_Mi   << "[0m\n";
	cout << Key << ": error(M*Mi)   = " << (err_MMi >Tol ? "[1;31m" : "[1;32m") << err_MMi  << "[0m\n";
	cout << Key << ": error(M*Mi*M) = " << (err_MMiM>Tol ? "[1;31m" : "[1;32m") << err_MMiM << "[0m\n";
	return err_Mi + err_MMi + err_MMiM;
}

double CheckDet (char const * Key, Mat_t const & M, double CorrectDet, double Tol)
{
	double detM     = Det(M);
	double err_detM = fabs(detM - CorrectDet);
	cout << Key << ": error(Det)    = " << (err_detM>Tol ? "[1;31m" : "[1;32m") << err_detM << "[0m\n";
	return err_detM;
}

int main(int argc, char **argv) try
{
	///// SVD correct values //////////////////////////////////////////////////////////////////////////////////////////////////////////
	
    Mat_t corInvA(2,2);
    corInvA =
     -2.0000000000000000e+00,  1.0000000000000000e+00,
      1.5000000000000000e+00, -5.0000000000000000e-01;

    Mat_t corUA(2,2);
    corUA =
     -4.0455358483375697e-01, -9.1451429567730447e-01,
     -9.1451429567730458e-01,  4.0455358483375692e-01;

    Vec_t corSA(2);
    corSA =
      5.4649857042190426e+00,  3.6596619062625751e-01;

    Mat_t corVtA(2,2);
    corVtA =
     -5.7604843676632078e-01, -8.1741556047036323e-01,
      8.1741556047036323e-01, -5.7604843676632078e-01;

    Mat_t corInvB(3,3);
    corInvB =
      1.0423452768729642e-01, -3.2573289902280136e-03, -6.5146579804560255e-03,
     -1.2667390517553386e-02,  5.2479189287006879e-02, -6.1527325370973572e-03,
     -1.4838943177705389e-02, -9.9529496923633724e-03,  3.5649656170828804e-02;

    Mat_t corUB(3,3);
    corUB =
      1.3141755556410686e-01,  4.4742200224954710e-02, -9.9031689958749303e-01,
      3.6969554284917222e-01,  9.2470200356647714e-01,  9.0837273173509273e-02,
      9.1981228067851462e-01, -3.7805335618027919e-01,  1.0498108493350734e-01;

    Vec_t corSB(3);
    corSB =
      3.2864331638810626e+01,  1.7987569607075308e+01,  9.3478898990569999e+00;

    Mat_t corVtB(3,3);
    corVtB =
      2.1367614180500336e-01,  3.9691061543495060e-01,  8.9263904786782489e-01,
      7.4010067014497569e-02,  9.0453921735335097e-01, -4.1991822328912670e-01,
     -9.7409702617544103e-01,  1.5579078157848747e-01,  1.6390306882827524e-01;

    Mat_t corInvC(5,5);
    corInvC =
      6.9128803717996279e-01, -7.4226114383340802e-01, -9.8756287260606410e-02, -6.9062496266472417e-01,  7.2471057693456553e-01,
      1.5936129795342968e+00, -1.7482347881148397e+00, -2.8304321334273236e-01, -1.5600769405383470e+00,  1.7164430532490673e+00,
     -1.6345384165063759e+00,  1.7495848317224429e+00,  2.7469205863729274e-01,  1.6325730875377857e+00, -1.7065745928961444e+00,
     -1.1177465024312745e+00,  1.3261729250546601e+00,  2.1243473793622566e-01,  1.1258168958554866e+00, -1.3325766717243535e+00,
      7.9976941733073770e-01, -8.9457712572131853e-01, -1.4770432850264653e-01, -8.0791149448632715e-01,  9.2990525800169743e-01;

    Mat_t corUC(5,5);
    corUC =
     -4.9131480299834873e-01, -3.9682713933839858e-01,  2.6940884231597306e-01,  5.5024083870837626e-01,  4.7517563167598015e-01,
     -1.8436234721034561e-01, -4.5587438252398499e-01, -6.3940295404484160e-01,  2.7258142302445876e-01, -5.2445429016279244e-01,
     -6.4666260791872432e-01,  7.1959191011975421e-01, -2.0909148108726730e-01,  1.1570356718901351e-01, -8.3116734093853104e-02,
     -4.7937866776415455e-01, -2.6140673166893563e-01,  5.1576653173706322e-01, -4.6093491312241469e-01, -4.7263781496573321e-01,
     -2.7684626365223813e-01, -2.2036508882136277e-01, -4.5699931653926035e-01, -6.3014766336473327e-01,  5.1851800447926977e-01;

    Vec_t corSC(5);
    corSC =
      7.6986806318205680e+01,  4.6904429440544916e+01,  3.2931871778592146e+01,  8.1528007049378086e+00,  1.7266616332203916e-01;

    Mat_t corVtC(5,5);
    corVtC =
     -6.5404770601013151e-01, -3.8083496832132990e-01, -5.6043632545196509e-01, -2.6778192710204507e-01, -2.0344603657478880e-01,
      6.4844738712320205e-01, -4.4646185600181121e-01, -9.3417253067825071e-02, -4.1240888414037769e-01, -4.4875374803990237e-01,
     -1.9434098201682845e-01,  5.6949301281812137e-01,  1.7932721763630147e-01, -1.2720485785435223e-01, -7.6783459430605894e-01,
      2.3056394573648911e-01,  4.1309070476231217e-02, -5.5291118097154834e-01,  7.4868432524463224e-01, -2.8088224349796215e-01,
      2.4659568940095572e-01,  5.7411480305496243e-01, -5.8250778270734838e-01, -4.2603105176835093e-01,  2.9793453122548685e-01;

    Mat_t corInvD(6,5);
    corInvD =
      5.6387724512344639e-01, -6.0176177188969326e-01, -7.6500652148749224e-02, -5.6389938864086908e-01,  5.8595836573334192e-01,
      1.2836912791395787e+00, -1.4064756360496755e+00, -2.2890726327210095e-01, -1.2518220058421685e+00,  1.3789338004227019e+00,
     -1.2866745075158739e+00,  1.3659857664770796e+00,  2.1392850711928030e-01,  1.2865799982753852e+00, -1.3277457214130808e+00,
     -8.8185982449865485e-01,  1.0660542211012198e+00,  1.7123094548599221e-01,  8.9119882164767850e-01, -1.0756926383722674e+00,
      6.6698814093525072e-01, -7.4815557352521045e-01, -1.2451059750508876e-01, -6.7584431870600359e-01,  7.8530451101142418e-01,
     -1.1017522295492406e+00,  1.2149323757487696e+00,  1.9244991110051662e-01,  1.0958269819071325e+00, -1.1998242501940171e+00;

    Mat_t corUD(5,5);
    corUD =
     -4.9134641821430736e-01, -3.9654593381869713e-01,  2.6969466617905058e-01, -5.5035808842949174e-01,  4.7507976300262911e-01,
     -1.8466237069699065e-01, -4.5599501615191240e-01, -6.3923167548419257e-01, -2.7255716679474540e-01, -5.2446526098463120e-01,
     -6.4645895856412139e-01,  7.1975659841187978e-01, -2.0914782647935071e-01, -1.1570671010401365e-01, -8.3128802773890911e-02,
     -4.7939233161342643e-01, -2.6112636456376553e-01,  5.1589286084700781e-01,  4.6103144323955003e-01, -4.7254690623418666e-01,
     -2.7704207882372661e-01, -2.2041626162501282e-01, -4.5690195326601007e-01,  6.2998454815211136e-01,  5.1867565237204494e-01;

    Vec_t corSD(5);
    corSD =
      7.7014865318747823e+01,  4.6908455948081922e+01,  3.2935977064026730e+01,  8.1542263932259971e+00,  1.9309911422710271e-01;

    Mat_t corVtD(6,6);
    corVtD =
     -6.5369127347784717e-01, -3.8073471443230489e-01, -5.6023767490692800e-01, -2.6777827223445061e-01, -2.0354039088541623e-01, -2.6993518060551665e-02,
      6.4872217515603159e-01, -4.4609442778054498e-01, -9.3062263880015858e-02, -4.1224275453843939e-01, -4.4875730009991766e-01, -1.3096295014004352e-02,
     -1.9423579040903360e-01,  5.6980367522048458e-01,  1.7962443040336673e-01, -1.2686673893611089e-01, -7.6745498231288434e-01, -1.5778913350383474e-02,
     -2.3075574358570788e-01, -4.1432247961041974e-02,  5.5256375827061910e-01, -7.4883247068841796e-01,  2.8037314818686448e-01,  1.8688961860319389e-02,
      2.2404140694784896e-01,  5.1621111891408278e-01, -5.1018861762046985e-01, -3.8066887629061874e-01,  2.7927752345221851e-01, -4.4736380570051276e-01,
      1.0332933242284395e-01,  2.5134450456075846e-01, -2.8211539155996829e-01, -1.9130257778641213e-01,  1.0768476066071979e-01,  8.9351396798642113e-01;

    Mat_t corInvE(5,4);
    corInvE =
        0.2,   0.0, 0.0, 0.0,
        0.0,   0.0, 0.0, 1./4.,
        0.0, 1./3., 0.0, 0.0,
        0.0,   0.0, 0.0, 0.0,
        0.4,   0.0, 0.0, 0.0;

    Mat_t corUE(4,4);
    corUE =
        0., 0., 1.,  0.,
        0., 1., 0.,  0.,
        0., 0., 0., -1.,
        1., 0., 0.,  0.;

    Vec_t corSE(4);
    corSE = 4., 3., sqrt(5.0), 0.;

    Mat_t corVtE(5,5);
    corVtE =
        0.         , 1. , 0. , 0. , 0.       , 
        0.         , 0. , 1. , 0. , 0.       , 
         sqrt(0.2) , 0. , 0. , 0. , sqrt(0.8), 
        0.         , 0. , 0. , 1. , 0.       , 
        -sqrt(0.8) , 0. , 0. , 0. , sqrt(0.2);

	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	double tol   = 1.0e-11;
	double error = 0.0;

	cout << "--- A --------------------------------------------\n";
	Mat_t A(2,2);
	A = 1,  2,
	    3,  4;
	double corDetA = -2.0;
	error += CheckInv ("A", A, corInvA, tol);
	error += CheckDet ("A", A, corDetA, tol);
	error += CheckSvd ("A", A, corUA, corSA, corVtA, tol);

	cout << "\n--- B --------------------------------------------\n";
	Mat_t B(3,3);
	B = 10,  1,  2,
	     3, 20,  4,
	     5,  6, 30;
	double corDetB = 5526.0;
	error += CheckInv ("B", B, corInvB, tol);
	error += CheckDet ("B", B, corDetB, tol);
	error += CheckSvd ("B", B, corUB, corSB, corVtB, tol);

	cout << "\n--- C --------------------------------------------\n";
	Mat_t C(5,5);
	C = 12, 28, 22, 20,  8,
	     0,  3,  5, 17, 28,
	    56,  0, 23,  1,  0,
	    12, 29, 27, 10,  1,
	     9,  4, 13,  8, 22;
	double corDetC = -167402.0;
	error += CheckInv ("C", C, corInvC, tol);
	error += CheckDet ("C", C, corDetC, tol);
	error += CheckSvd ("C", C, corUC, corSC, corVtC, tol);

	cout << "\n--- D --------------------------------------------\n";
	Mat_t D(5,6);
	D = 12, 28, 22, 20,  8,  1,
	     0,  3,  5, 17, 28,  1,
	    56,  0, 23,  1,  0,  1,
	    12, 29, 27, 10,  1,  1,
	     9,  4, 13,  8, 22,  1;
	error += CheckInv ("D", D, corInvD, tol);
	error += CheckSvd ("D", D, corUD, corSD, corVtD, tol);

	cout << "\n--- E --------------------------------------------\n";
	Mat_t E(4,5);
	E = 1, 0, 0, 0, 2,
        0, 0, 3, 0, 0,
        0, 0, 0, 0, 0,
        0, 4, 0, 0, 0;
	error += CheckInv ("E", E, corInvE, tol);
	error += CheckSvd ("E", E, corUE, corSE, corVtE, tol);

	cout << "\n--- error ----------------------------------------\n";
	cout << "error = " << (error>tol ? "[1;31m" : "[1;32m") << error << "[0m" << endl;

	if (error>tol) return 1;
	else return 0;
}
MECHSYS_CATCH
